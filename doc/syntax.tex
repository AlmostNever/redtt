\documentclass{article}

% for dumb dingbats
\usepackage{fontawesome}
\usepackage{dingbat}

\usepackage{amssymb}


\usepackage[tt=false]{libertine}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{fullpage}

\usepackage{mathtools}

\DeclarePairedDelimiter\Parens{\lparen}{\rparen}
\DeclarePairedDelimiter\Angles{\langle}{\rangle}
\DeclarePairedDelimiter\Squares{[}{]}

\DeclarePairedDelimiter\Braces{\lbrace}{\rbrace}
\DeclarePairedDelimiter\Pipes{\lvert}{\rvert}

\newcommand\Len[1]{\Pipes*{#1}}

\newtheorem{remark}{Remark}



\usepackage{stmaryrd}

\title{Cartesian Cubical Type Theory:\\ Operational Semantics and
  Definitional Equivalence} \author{Jon Sterling}

\newcommand\FmtKwd[1]{\mathsf{#1}}

\newcommand\DeclBox[1]{\framebox{$\displaystyle{}#1$}}
\newcommand\FmtThin[1]{{\color{ProcessBlue}#1}}
\newcommand\XThin[3]{{#2}\rightarrowtriangle_{#1}{#3}}

\newcommand\Thin[2]{{#1}\rightarrowtriangle{#2}}
\newcommand\IsThin[3]{\FmtThin{#1}:\Thin{#2}{#3}}
\newcommand\IsXThin[4]{\FmtThin{#1}:\XThin{#2}{#3}{#4}}

\newcommand\ThinId{\mathsf{id}}
\newcommand\ThinKeep[1]{\mbox{\leftthumbsdown}\!\!\rangle\!{#1}\!\langle\!\!\mbox{\rightthumbsdown}}
\newcommand\ThinSkip[1]{{#1}.\mbox{\faTrashO}}
\newcommand\ThinRep[2]{{#1}.\Squares*{{\normalcolor{}#2}}}

\usepackage{xinttools}

\newcommand\FormatList[3]{%
  \xintFor ##1 in {#3} \do{%
    #1{##1}%
    \xintifForLast{}{#2}
  }
}



\newcommand\THIN{\mathbf{Thin}}
\newcommand\OpCat[1]{{#1}^{\mathsf{op}}}
\newcommand\SET{\mathbf{Set}}

\newcommand\Interval{\FmtKwd{dim}}
\newcommand\Bool{\FmtKwd{bool}}
\newcommand\Atom[1]{{\boldsymbol\alpha}_{#1}}
\newcommand\Var[1]{\mathsf{v}_{#1}}

\newcommand\SortChk{\FmtKwd{chk}}
\newcommand\SortInf{\FmtKwd{inf}}

\newcommand\Tm[3]{{#1}\mid{#2}\vdash{#3}}
\newcommand\FmtTm[1]{{\color{Violet}#1}}
\newcommand\IsTm[4]{{#1}\mid{#2}\vdash\FmtTm{#3}:{#4}}
\newcommand\IsChk[3]{\IsTm{#1}{#2}{#3}{\SortChk}}
\newcommand\IsInf[3]{\IsTm{#1}{#2}{#3}{\SortInf}}

\newcommand\TExp[2]{
  \FmtTm{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}


\newcommand\FmtVal[1]{{\color{Red}{#1}}}

\newcommand\VExp[2]{
  \FmtVal{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}


\newcommand\EvalClo[2]{\FmtVal{#1}\Downarrow\FmtVal{#2}}
\newcommand\Eval[5]{\FmtThin{#2}*\FmtVal{#3}\vDash\FmtTm{#4}\mathrel{\Downarrow_{\FmtThin{#1}}}\FmtVal{#5}}
\newcommand\Apply[3]{\FmtVal{#1}\mathrel{@}\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\InstClo[3]{\FmtVal{#1}\bullet\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\ThinVal[2]{\widehat{\FmtThin{#1}}\Parens*{\FmtVal{#2}}}
\newcommand\ThinTmAtom[2]{\widehat{\FmtThin{#1}}_{\Atom{}}\Parens*{\FmtTm{#2}}}
\newcommand\ThinTmVar[2]{\widehat{\FmtThin{#1}}_{\Var{}}\Parens*{\FmtTm{#2}}}
\newcommand\Car[2]{\FmtVal{#1}\ \mathbf{car}\Downarrow\FmtVal{#2}}
\newcommand\Cdr[2]{\FmtVal{#1}\ \mathbf{cdr}\Downarrow\FmtVal{#2}}


\begin{document}
\maketitle

The purpose of these notes is to develop an operational semantics and
algorithmic theory of definitional equivalence for cartesian cubical
type theory which is as efficient and carefully organized as possible:
in particular, we arrange to calculate all substitutions and renamings
lazily using environments and closures. Our definition of both the
syntactic and the semantic domain is strongly scoped, which makes it
easier to verify the that we have correctly resolved the contradiction
between the name and the location of a bound variable.

In these notes, we use colors to distinguish objects of different
(meta) sorts from each other, in order to avoid getting lost in a
hurricane of superscripts. As such, $\FmtTm{M}$ and $\FmtVal{M}$ are
to be understood as distinct schematic variables. Some of the ideas
for dealing with evaluation under dimension binders come from joint
work with Favonia and Daniel Gratzer and Carlo Angiuli; the idea of
generalized thinnings comes from Conor McBride (as far as I am aware).

\section{Defunctionalized NbE}

I develop an open operational semantics for Cartesian Cubical Type
Theory inspired by normalization-by-evaluation (NbE), in its
\emph{defunctionalized} variant. Often NbE is presented using domain
models and binding is represented using meta-level functions, and
evaluation and quotation are intertwined. My perspective is that the
correct theoretical development of a concept should mirror a practical
implementation; therefore, we choose to suspend in syntax the
structure of the NbE algorithm, using closures and shifts in the
semantic domain. In this style of NbE, the evaluation function is
called from the quotation function, but not vice versa.

\paragraph{Why NbE?}

The old practice of regarding computation as a kind of rewriting
system does not scale cleanly to calculation with
indeterminates. Inefficiency is not the only nail in the coffin of the
old heroic attempts to unleash open computation by attacking a term
with rewriting rules; it is typical of \emph{rewriting-theory
  dogmato-revisionism} to account for only one half of the dialectic
of open term behavior: indeed, any account of computation for open
terms of negative type must explain not only reduction, but also
expansion.


\section{Thinnings}

$X$-Thinnings are a defunctionalized representation of substitutions
which capture the idea of deleting some variables from within a
context, or possibly replacing them with an element of the family
$X:\SET^{\mathbb{N}}$. When $X$ is the empty family, these correspond
to the \emph{order-preserving embeddings} of Chapman.
%
We choose a representation of thinnings which lends itself to
efficient calculation, but is not canonical; therefore, any operation
on thinnings must be proved to be respect the algebraic laws of
thinnings in order to be well-defined.
\begin{mathparpagebreakable}
  \DeclBox{
    \IsXThin{f}{X}{n}{m}
  }
  \\
  \inferrule{
  }{
    \IsXThin{\ThinId}{X}{n}{n}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{n}{m}
  }{
    \IsXThin{\ThinKeep{f}}{X}{n+1}{m+1}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{n}{m}
  }{
    \IsXThin{\ThinSkip{f}}{X}{n+1}{m}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{n}{m}
    \\
    a:X_n
  }{
    \IsXThin{\ThinRep{f}{a}}{X}{n}{m+1}
  }
\end{mathparpagebreakable}

We will write $\THIN$ for the category of $\varnothing$-thinnings
induced by the above. To simplify notation, we write $\Thin{n}{m}$ for
$\XThin{\varnothing}{n}{m}$.

\section{Terms}

\newcommand\TSubstA[3]{
  \TExp{subst_{\Atom{}}}{
    \FmtThin{#1}%
    \mathbin{{\color{gray}*}}%
    \FmtThin{#2},
    \FmtThin{#3}
  }
}

\newcommand\TThinV[2]{
  \TExp{thin_{\Var{}}}{
    \FmtThin{#1},
    #2
  }
}


In our term language, we distinguish between \emph{atoms} and
\emph{variables}, and their respective binders. Variable binders are
given operational meaning through substitution, whereas atom binders
are subject to open evaluation. Most binders are variable binders; the
only atom binder in our language comes from $\FmtKwd{coe}$.


\begin{remark}
  This is a matter of some subtlety in the context of
  \emph{normalization-by-evaluation} in which the evaluation and
  quotation phases of computation are distinguished: while we do not
  evaluate underneath a variable binder, during the quotation phase we
  \emph{do} instantiate such a variable binder with a semantic
  indeterminate or generic element: so, even though we end up
  transforming the interior of the binder, this is still done through
  substitution. In contrast, we do evaluate underneath atom binders.
\end{remark}

\begin{remark}
  Note that the atom/variable distinction does not align with the
  distinction of dimension variables from other variables. Dimensions
  in our formal language are treated the same as other terms, and some
  dimensions are bound as atoms (such as in $\FmtKwd{coe}$) and others
  are bound as variables (as in path types and path
  abstractions). Note that we also treat path abstraction and
  functional abstraction uniformly using $\FmtKwd{lam}$.
\end{remark}


Terms are classified by sorts $\tau\in\Braces*{\SortChk,\SortInf}$; we
will write the judgment $\IsTm{n}{l}{M}{\tau}$ to mean that
$\FmtTm{M}$ is a term of sort $\tau$ with $n$ atoms and $l$
variables. In the term language, both atoms and variables are managed
using De Bruijn indices. An illustrative fragment of the syntax is
presented below.

\begin{mathparpagebreakable}
  \DeclBox{
    \IsTm{n}{l}{M}{\tau}
  }
  \\
  \and
  \inferrule[TmAtom]{
    i<n
  }{
    \IsInf{n}{l}{\Atom{i}}
  }
  \and
  \inferrule[TmVar]{
    i<l
  }{
    \IsInf{n}{l}{\Var{i}}
  }
  \and
  \inferrule[TmPi]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Pi}{A,B}
    }
  }
  \and
  \inferrule[TmSg]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Sigma}{A,B}
    }
  }
  \and
  \inferrule[TmEq]{
    \IsChk{n}{l+1}{A}
    \\
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{
      \TExp{eq}{A,M,N}
    }
  }
  \and
  \inferrule[TmLam]{
    \IsChk{n}{l+1}{M}
  }{
    \IsChk{n}{l}{\TExp{\lambda}{M}}
  }
  \and
  \inferrule[TmCons]{
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{\TExp{cons}{M,N}}
  }
  \and
  \inferrule[TmCar]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{car}{R}}
  }
  \and
  \inferrule[TmCdr]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{cdr}{R}}
  }
  \and
  \inferrule[TmDim0]{
  }{
    \IsChk{n}{l}{0}
  }
  \and
  \inferrule[TmDim1]{
  }{
    \IsChk{n}{l}{1}
  }
  \and
  \inferrule[TmUp]{
    \IsInf{n}{l}{R}
  }{
    \IsChk{n}{l}{\TExp{\uparrow}{R}}
  }
  \and
  \inferrule[TmApp]{
    \IsInf{n}{l}{R}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{@}{R,M}}
  }
  \and
  \inferrule[TmDown]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{\downarrow}{A,M}}
  }
  \and
  \inferrule[TmCoe]{
    \IsChk{n}{l}{I}
    \\
    \IsChk{n}{l}{J}
    \\
    \IsChk{n+1}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{
      \TExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
  \and
  \inferrule[TmSubstAtom]{
    \IsTm{m}{l}{M}{\tau}
    \\
    \IsXThin{f}{\Parens*{\Tm{\square}{k}{\SortInf}}}{n}{m}
    \\
    \IsThin{g}{l}{k}
  }{
    \IsTm{n}{l}{
      \TSubstA{g}{f}{M}
    }{\tau}
  }
  \and
  \inferrule[TmThinVar]{
    \IsTm{m}{k}{M}{\tau}
    \\
    \IsThin{f}{l}{k}
  }{
    \IsTm{n}{l}{
      \TThinV{f}{M}
    }{\tau}
  }
\end{mathparpagebreakable}


\newcommand\PushSubstA[4]{\Squares*{\FmtThin{#1}*\FmtThin{#2}}*\FmtTm{#3}\leadsto\FmtTm{#4}}
\newcommand\PushThinV[3]{\FmtThin{#1}*\FmtTm{#2}\leadsto\FmtTm{#3}}

\subsection{Explicit Substitutions}

In the term language, we have explicit substitutions of atoms
$\TSubstA{g}{f}{M}$ and thinnings of variables $\TThinV{f}{M}$; these
can be cheaply \emph{pushed} inward in the following way:

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgSubstA]{
      \IsTm{m}{l}{M}{\tau}
      \\
      \IsXThin{f}{\Parens*{\Tm{\square}{l'}{\SortInf}}}{n}{m}
      \\
      \IsThin{g}{l}{l'}
      \\
      \IsTm{n}{l}{N}{\tau}
    }{
      \DeclBox{
        \PushSubstA{g^+}{f^+}{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[SubstAId]{}{
    \PushSubstA{g}{\ThinId}{M}{M}
  }
  \and
  \inferrule[SubstASubstAtom]{
    \PushSubstA{g'}{f'}{M}{M'}
    \\
    \PushSubstA{g}{f}{M'}{M''}
  }{
    \PushSubstA{g}{f}{
      \TSubstA{g'}{f'}{M}
    }{
      M''
    }
  }
  \and
  \inferrule[SubstAThinV]{
    \PushThinV{h}{M}{M'}
    \\
    \PushSubstA{g}{f}{M'}{M''}
  }{
    \PushSubstA{g}{f}{\TThinV{h}{M}}{M''}
  }
  \and
  \inferrule[SubstAAtom]{
    \PushSubstA{\ThinId}{\ThinId}{f_{\Atom{}}\Parens{i}}{M}
  }{
    \PushSubstA{g}{f}{\Atom{i}}{
      \ThinTmVar{g}{M}
    }
  }
  \and
  \inferrule[SubstAVar]{}{
    \PushSubstA{g}{f}{\Var{i}}{g_{\Var{\square}}\Parens{i}}
  }
  \and
  \inferrule[SubstALam]{}{
    \PushSubstA{g}{f}{
      \TExp{\lambda}{M}
    }{
      \TExp{\lambda}{
        \TSubstA{\ThinSkip{g}}{f}{M}
      }
    }
  }
  \\
  \inferrule[SubstACoe]{}{
    \PushSubstA{g}{f}{
      \TExp{coe}{
        I,
        J,
        A,
        M
      }
    }{
      \TExp{coe}{
        \TSubstA{g}{f}{I},
        \TSubstA{g}{f}{J},
        \TSubstA{g}{\ThinSkip{f}}{A},
        \TSubstA{g}{f}{M}
      }
    }
  }
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgThinV]{
      \IsTm{n}{k}{M}{\tau}
      \\
      \IsThin{f}{l}{k}
      \\
      \IsTm{n}{l}{N}{\tau}
    }{
      \DeclBox{
        \PushThinV{f^+}{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[ThinVId]{}{
    \PushThinV{\ThinId}{M}{M}
  }
  \and
  \inferrule[ThinVSubstA]{
    \PushSubstA{g}{f}{M}{M'}
    \\
    \PushThinV{h}{M'}{M''}
  }{
    \PushThinV{h}{
      \TSubstA{g}{f}{M}
    }{M''}
  }
  \and
  \inferrule[ThinVThinV]{
    \PushThinV{f}{M}{M'}
    \\
    \PushThinV{g}{M'}{M''}
  }{
    \PushThinV{g}{
      \TThinV{f}{M}
    }{M''}
  }
  \and
  \inferrule[ThinVLam]{}{
    \PushThinV{f}{
      \TExp{\lambda}{M}
    }{
      \TExp{\lambda}{
        \TThinV{\ThinSkip{f}}{M}
      }
    }
  }
\end{mathparpagebreakable}

\section{Semantic Domain}

The semantic domain of our language is really another syntax, in which
variables are replaced by semantic indeterminates (represented as De
Bruijn levels), and atoms remain represented as De Bruijn indices. The
semantic domain captures the weak-head normal forms of our language;
because we intend to develop a substitution-free operational semantics
using environments, we must naturally employ a notion of
\emph{closure}.

\newcommand\SortCan{\FmtKwd{can}}
\newcommand\SortNeu{\FmtKwd{neu}}
\newcommand\SortClo{\FmtKwd{clo}}
\newcommand\SortBClo{\FmtKwd{bclo}}
\newcommand\SortEnv[1]{\FmtKwd{env}_{#1}}
\newcommand\IsVal[3]{{#1}\Vdash\FmtVal{#2}:{#3}}
\newcommand\Val[2]{{#1}\Vdash{#2}}

\newcommand\Clo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}

\newcommand\BClo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft^+}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}


Values are classified by sorts
$\tau\in\Braces*{\SortCan,\SortNeu,\SortEnv{l},\SortClo,\SortBClo}$; for
such a sort $\tau$, we will write $\IsVal{n}{M}{\tau}$ to mean that
$\FmtVal{M}$ is a value of sort $\tau$ with $n$ atoms. We no longer
track the number of variables, because these are replaced by
indeterminates in the form of De Bruijn levels (which have an absolute
reference).

\begin{mathparpagebreakable}
  \DeclBox{
    \IsVal{n}{M}{\tau}
  }
  \\
  \inferrule[ValAtom]{
    i<n
  }{
    \IsVal{n}{\Atom{i}}{\SortCan}
  }
  \and
  \inferrule[ValGen]{
  }{
    \IsVal{n}{\Var{l}}{\SortNeu}
  }
  \and
  \inferrule[ValUp]{
    \IsVal{n}{A}{\SortCan}
    \\
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{
      \VExp{\uparrow}{A,R}
    }{\SortCan}
  }
  \and
  \inferrule[ValClo]{
    \IsThin{g}{o}{n}
    \\
    \IsThin{f}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l}{M}{\SortChk}
  }{
    \IsVal{o}{
      \Clo{g}{f}{\rho}{M}
    }{\SortClo}
  }
  \and
  \inferrule[ValBClo]{
    \IsThin{g}{o}{n}
    \\
    \IsThin{f}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l+1}{M}{\SortChk}
  }{
    \IsVal{o}{
      \BClo{g}{f}{\rho}{M}
    }{\SortBClo}
  }
  \and
  \inferrule[ValEnv]{
    \forall{i<l}.\ \IsVal{n}{M_i}{\SortCan}
  }{
    \IsVal{n}{\Squares{M_i}_{i<l}}{\SortEnv{l}}
  }
  \\
  \inferrule[ValPi]{
    \IsVal{n}{A}{\SortClo}
    \\
    \IsVal{n}{A}{\SortBClo}
  }{
    \IsVal{n}{
      \VExp{\Pi}{A,B}
    }{\SortCan}
  }
  \and
  \inferrule[ValLam]{
    \IsVal{n}{M}{\SortClo}
  }{
    \IsVal{n}{\VExp{\lambda}{M}}{\SortCan}
  }
  \and
  \inferrule[ValApp]{
    \IsVal{n}{R}{\SortNeu}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{\VExp{@}{R,M}}{\SortNeu}
  }
  \and
  \inferrule[ValCons]{
    \IsVal{n}{M}{\SortClo}
    \\
    \IsVal{n}{N}{\SortClo}
  }{
    \IsVal{n}{\VExp{cons}{M,N}}{\SortCan}
  }
  \and
  \inferrule[ValCar]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{car}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCdr]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{cdr}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCoe]{
    \IsVal{n}{I}{\SortCan}
    \\
    \IsVal{n}{J}{\SortCan}
    \\
    \IsVal{n+1}{A}{\SortCan}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{
      \VExp{coe}{I,J,A,M}
    }{\SortCan}
  }
\end{mathparpagebreakable}


The syntax of values can be reindexed contravariantly along
thinnings $\IsThin{f}{m}{n}$; the
reindexing action is renaming.



\section{Evaluation}


At a high level, evaluation takes terms to values; at a finer-grained
level, however, we will evaluate with respect to a thinning
$\FmtThin{g}$ and an environment $\FmtVal{\rho}$ together with a
thinning $\FmtThin{f}$; this allows us to avoid actually executing
thinnings and substitutions until the last moment possible. In fact,
the preceding sentence can be rephrased as construing evaluation as a
relation $\EvalClo{M_\SortClo}{M_\SortCan}$ where
$\IsVal{n}{M_\SortClo}{\SortClo}$ and
$\IsVal{n}{M_\SortCan}{\SortCan}$.

We will write $\Eval{g}{f}{\rho}{M}{M}$ as a notation for
$\EvalClo{\Clo{g}{f}{\rho}{M}}{M}$, when it is well-formed:


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgEval]{
      \IsThin{g}{o}{n}
      \\
      \IsThin{f}{n}{m}
      \\
      \IsVal{m}{\rho}{\SortEnv{l}}
      \\
      \IsTm{n}{l}{M}{\tau}
      \\
      \IsVal{o}{M}{\SortCan}
    }{
      \DeclBox{
        \Eval{g^+}{f^+}{\rho^+}{M^+}{M^-}
      }
    }
  }
  \\
  \inferrule[EvalSubstA]{
    \PushSubstA{j}{h}{M}{M'}
    \\
    \Eval{g}{f}{\rho}{M'}{M'}
  }{
    \Eval{g}{f}{\rho}{
      \TSubstA{j}{h}{M}
    }{M'}
  }
  \and
  \inferrule[EvalThinV]{
    \PushThinV{h}{M}{M'}
    \\
    \Eval{g}{f}{\rho}{M'}{M'}
  }{
    \Eval{g}{f}{\rho}{
      \TThinV{h}{M}
    }{M'}
  }
  \and
  \inferrule[EvalAtom]{}{
    \Eval{g}{f}{\rho}{\Atom{i}}{
      \ThinVal{g}{\Atom{i}}
    }
  }
  \and
  \inferrule[EvalVar]{}{
    \Eval{g}{f}{\rho}{\Var{l}}{
      \ThinVal{
        g\circ{}f
      }{\rho_l}
    }
  }
  \and
  \inferrule[EvalPi]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Pi}{A,B}
    }{
      \VExp{\Pi}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalSg]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Sigma}{A,B}
    }{
      \VExp{\Sigma}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalPath]{}{
    \Eval{g}{f}{\rho}{
      \TExp{path}{A,M,N}
    }{
      \VExp{path}{
        \BClo{g}{f}{\rho}{A},
        \Clo{g}{f}{\rho}{M},
        \Clo{g}{f}{\rho}{N}
      }
    }
  }
  \and
  \inferrule[EvalLam]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\lambda}{M}
    }{
      \VExp{\lambda}{
        \BClo{g}{f}{\rho}{M}
      }
    }
  }
  \and
  \and
  \inferrule[EvalUp]{
    \Eval{g}{f}{\rho}{R}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\uparrow}{R}
    }{
      M
    }
  }
  \and
  \inferrule[EvalDown]{
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\downarrow}{A,M}
    }{M}
  }
  \and
  \inferrule[EvalCoe]{
    \Eval{g}{f}{\rho}{I}{I}
    \\
    \Eval{g}{f}{\rho}{J}{J}
    \\
    \Eval{\ThinKeep{g}}{\ThinSkip{f}}{\rho}{A}{A}
    \\
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{coe}{I,J,A,M}
    }{
      \VExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
  \and
  \inferrule[EvalApp]{
    \Eval{g}{f}{\rho}{R}{M_{\mathsf{fun}}}
    \\
    \Eval{g}{f}{\rho}{M}{M_{\mathsf{arg}}}
    \\
    \Apply{M_{\mathsf{fun}}}{M_{\mathsf{arg}}}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{@}{
        R,
        M
      }
    }{
      N
    }
  }
  \and
  \inferrule[EvalCar]{
    \Eval{g}{f}{\rho}{R}{M}
    \\
    \Car{M}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{car}{R}
    }{N}
  }
  \and
  \inferrule[EvalCdr]{
    \Eval{g}{f}{\rho}{R}{M}
    \\
    \Cdr{M}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{cdr}{R}
    }{N}
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgInst]{
      \IsVal{n}{M}{\SortBClo}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\InstClo{M^+}{N^+}{O^-}}
    }
  }
  \and
  \inferrule[InstBClo]{
    \Eval{g}{f}{\Squares*{N,\rho}}{M}{O}
  }{
    \InstClo{
      \BClo{g}{f}{\rho}{M}
    }{N}{O}
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgApply]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\Apply{M^+}{N^+}{O^-}}
    }
  }
  \\
  \inferrule[ApplyLam]{
    \InstClo{M}{N}{O}
  }{
    \Apply{\VExp{\lambda}{M}}{N}{O}
  }
  \and
  \inferrule[ApplyUpPi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortClo}{N}{B_\SortCan}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        R
      }
    }{N}{
      \VExp{\uparrow}{
        B_\SortCan,
        \VExp{@}{
          R,
          N
        }
      }
    }
  }
  \and
  \inferrule[ApplyUpPathConst]{
    \EvalClo{M_\SortClo^\epsilon}{M_\SortCan^\epsilon}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{path}{A,M_\SortClo^0,M_\SortClo^1},
        R
      }
    }{\epsilon}{M_\SortCan^\epsilon}
  }
  \and
  \inferrule[ApplyUpPathNeu]{
    \InstClo{A_\SortBClo}{
      \VExp{\uparrow}{
        \Interval,
        S
      }
    }{A_\SortCan}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{path}{A_\SortBClo,M_\SortClo^0,M_\SortClo^1},
        R
      }
    }{
      \VExp{\uparrow}{
        \Interval,
        S
      }
    }{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{@}{
          R,
          \VExp{\uparrow}{
            \Interval,
            S
          }
        }
      }
    }
  }
  \and
  \inferrule[ApplyCoePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{coe}{
        \ThinVal{\ThinSkip{\ThinId}}{J},
        \Atom{0},
        \ThinVal{
          \ThinKeep{\ThinSkip{\ThinId}}
        }{A_\SortCan},
        \ThinVal{\ThinSkip{\ThinId}}{N}
      }
    }{
      B_\SortCan{}
    }
    \\
    \Apply{M}{
      \VExp{coe}{
        J,
        I,
        A_\SortCan,
        N
      }
    }{O}
  }{
    \Apply{
      \VExp{coe}{
        I,
        J,
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        M
      }
    }{N}{
      \VExp{coe}{
        I,
        J,
        B_\SortCan,
        O
      }
    }
  }
\end{mathparpagebreakable}

Observe how in \textsc{ApplyCoePi}, we used in an essential way the
fact that the dimension binder of $\FmtKwd{coe}$ abstracts an
\emph{atom} rather than a \emph{variable}; in the semantic domain,
this means that we may name this dimension using an atom of the $0$th
De Bruijn index. This is essential: if we had bound a variable rather
than an atom, it would be impossible from this point of view of the
application judgment to know the De Bruijn level of the bound
dimension.

The cost of this solution to the problem of evaluating under binders
is that we must be careful to apply thinnings in all the right
places. It is easy to verify that the semantic term is well-formed
using the strongly-scoepd term formation rules given; moreover, the
thinnings will generally be inexpensive, since they tend to pile up on
closures.

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCar]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
    }{
      \DeclBox{
        \Car{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[CarCons]{}{
    \Car{
      \VExp{cons}{M,N}
    }{M}
  }
  \and
  \inferrule[CarUpSg]{
    \EvalClo{A_\SortClo}{A_\SortCan}
  }{
    \Car{
      \VExp{\uparrow}{
        \VExp{\Sigma}{A_\SortClo,B_\SortBClo},
        R
      }
    }{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{car}{R}
      }
    }
  }
  \and
  \inferrule[CarCoeSg]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \Car{M}{N}
  }{
    \Car{
      \VExp{coe}{
        I,
        J,
        \VExp{\Sigma}{
          A_\SortClo,
          B_\SortBClo%
        },
        M
      }
    }{
      \VExp{coe}{
        I,
        J,
        A_\SortCan,
        N
      }
    }
  }
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCdr]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
    }{
      \DeclBox{
        \Cdr{M^+}{N^-}
      }
    }
  }
  \\
  \inferrule[CdrCons]{}{
    \Cdr{
      \VExp{cons}{M,N}
    }{N}
  }
  \and
  \inferrule[CdrUpSg]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{car}{R}
      }
    }{B_\SortCan}
  }{
    \Cdr{
      \VExp{\uparrow}{
        \VExp{\Sigma}{A_\SortClo,B_\SortBClo},
        R
      }
    }{
      \VExp{\uparrow}{
        B_\SortCan,
        \VExp{cdr}{R}
      }
    }
  }
  \and
  \inferrule[CdrCoeSg]{
    \Car{M}{M_0}
    \\
    \Cdr{M}{M_1}
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\\\
    \InstClo{B_\SortBClo}{
      \VExp{coe}{
        \ThinVal{\ThinSkip{\ThinId}}{I},
        \Atom{0},
        \ThinVal{\ThinKeep{\ThinSkip{\ThinId}}}{A_\SortCan},
        \ThinVal{\ThinSkip{\ThinId}}{M_0}
      }
    }{B_\SortCan}
  }{
    \Cdr{
      \VExp{coe}{
        I,
        J,
        \VExp{\Sigma}{
          A_\SortClo,
          B_\SortBClo%
        },
        M
      }
    }{
      \VExp{coe}{
        I,
        J,
        B_\SortCan,
        M_1
      }
    }
  }
\end{mathparpagebreakable}


\section{Quotation}

\newcommand\QuoteCan[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\ni\FmtVal{#3}\Uparrow\FmtTm{#4}
}

\newcommand\QuoteNeu[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\Uparrow\FmtTm{#3}\in\FmtVal{#4}
}

\newcommand\SortCtx[1]{\FmtKwd{ctx}_{#1}}

\subsection{Semantic contexts}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCtx]{}{
      \DeclBox{\IsVal{n^-}{\Gamma}{\SortCtx{l^-}}}
    }
  }
  \\
  \inferrule[CtxNil]{}{
    \IsVal{0}{\cdot}{\SortCtx{0}}
  }
  \and
  \inferrule[CtxExtVar]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n}{\Gamma.A}{\SortCtx{l+1}}
  }
  \and
  \inferrule[CtxExtAtom]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n+1}{\Gamma.\nabla{}A}{\SortCtx{l}}
  }
\end{mathparpagebreakable}

\subsection{Quotation and Definitional Equivalence}

To start with, I define a quotation from semantic values to syntactic
terms; together with evaluation, this generates a theory of
definitional equivalence. However, this is an inefficient way to
calculate definitional equivalence (the negative cases can be
devastating); worse, later on we will introduce programming constructs
(such as systems) which resist a sensible notion of normal form. As
such, the quotation algorithm defined below will serve as a template
for a binary generalization that checks definitional equivalence.

\newcommand\LookupAtom[4]{\FmtVal{#1}\ni\Atom{#2}:\Squares*{\FmtThin{#4}*\FmtVal{#3}}}
\newcommand\LookupVar[4]{\FmtVal{#1}\ni\Var{#2}:\Squares*{\FmtThin{#4}*\FmtVal{#3}}}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgQuoteCan]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{A}{\SortCan}
      \\
      \IsVal{n}{M}{\SortCan}
      \\
      \IsTm{n}{l}{M}{\SortChk}
    }{
      \DeclBox{\QuoteCan{\Gamma^+}{A^+}{M^+}{M^-}}
    }
  }
  \and
  \DeclBox{
    \inferrule[JdgQuoteNeu]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{R}{\SortNeu}
      \\
      \IsTm{n}{l}{R}{\SortInf}
      \\
      \IsVal{n}{A}{\SortCan}
    }{
      \DeclBox{\QuoteNeu{\Gamma^+}{R^+}{R^-}{A^-}}
    }
  }
  \\
  \inferrule[QuotePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \QuoteCan{\Gamma}{C}{A_\SortCan}{A}
    \\
    \InstClo{B_\SortClo}{
      \Var{\Len{\Gamma}}
    }{
      B_\SortCan{}
    }
    \\
    \QuoteCan{\Gamma.A_\SortCan}{C}{B_\SortCan}{B}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{\Pi}{A_\SortClo,B_\SortBClo}
    }{
      \TExp{\Pi}{
        A,
        B
      }
    }
  }
  \and
  \inferrule[QuoteLam]{
    \EvalClo{A}{A_\SortCan}
    \\
    \InstClo{B}{\Var{\Len{\Gamma}}}{B_\SortCan}
    \\
    \Apply{M}{\Var{\Len{\Gamma}}}{N}
    \\
    \QuoteCan{\Gamma.A_\SortCan}{B_\SortCan}{N}{N}
  }{
    \QuoteCan{\Gamma}{
      \VExp{\Pi}{A,B}
    }{M}{
      \TExp{\lambda}{N}
    }
  }
  \and
  \inferrule[QuoteCoeBool]{
    \QuoteCan{\Gamma}{\Bool}{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \Bool,
        M
      }
    }{
      M
    }
  }
  \and
  \inferrule[QuoteCoeUp]{
    \QuoteCan{\Gamma}{\Interval}{I}{I}
    \\
    \QuoteCan{\Gamma}{\Interval}{J}{J}
    \\\\
    \QuoteNeu{\Gamma.\nabla\Interval}{R}{R}{A'}
    \\
    \QuoteCan{\Gamma.\nabla\Interval}{\FmtKwd{U}}{A'}{A'}
    \\\\
    \PushSubstA{\ThinId}{
      \ThinRep{\ThinId}{
        \TExp{\downarrow}{
          \Interval,
          I
        }
      }
    }{A'}{A_I}
    \\
    \Eval{\ThinId}{\ThinId}{\parallel\Gamma\parallel}{A_I}{A_I}
    \\
    \QuoteCan{\Gamma}{A_I}{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \VExp{\uparrow}{A,R},
        M
      }
    }{
      \TExp{\uparrow}{
        \TExp{coe}{
          I,
          J,
          \TExp{\uparrow}{R},
          M
        }
      }
    }
  }
  \and
  \inferrule[QuoteAtom]{
    \LookupAtom{\Gamma}{i}{A}{f}
  }{
    \QuoteNeu{\Gamma}{\Atom{i}}{\Atom{i}}{\ThinVal{f}{A}}
  }
  \and
  \inferrule[QuoteVar]{
    \FmtTm{i}\equiv{\FmtTm{\Len{\FmtVal{\Gamma}}-\Parens*{\FmtVal{l}+1}}}
    \\
    \LookupVar{\Gamma}{i}{A}{f}
  }{
    \QuoteNeu{\Gamma}{\Var{l}}{
      \Var{i}
    }{
      \ThinVal{f}{A}
    }
  }
  \and
  \inferrule[QuoteApPi]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{\Pi}{A_\SortClo,B_\SortBClo}
    }
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{N}{B_\SortCan}
    \\
    \QuoteCan{\Gamma}{A_\SortCan}{N}{N}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{@}{R,N}
    }{
      \TExp{@}{R,N}
    }{
      B_\SortCan%
    }
  }
  \and
  \inferrule[QuoteApPath]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{path}{A_\SortBClo,M_0,M_1}
    }
    \\
    \InstClo{A_\SortClo}{N}{A_\SortCan}
    \\
    \QuoteCan{\Gamma}{\Interval}{N}{N}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{@}{R,N}
    }{
      \TExp{@}{R,N}
    }{
      A_\SortCan%
    }
  }
  \and
  \inferrule[QuoteCar]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{\Sigma}{A_\SortClo,B_\SortBClo}
    }
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{car}{R}
    }{
      \TExp{car}{R}
    }{A_\SortCan}
  }
  \and
  \inferrule[QuoteCdr]{
    \QuoteNeu{\Gamma}{R}{R}{
      \VExp{\Sigma}{A_\SortClo,B_\SortBClo}
    }
    \\
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{\uparrow}{
        A_\SortCan,
        \VExp{car}{R}
      }
    }{B_\SortCan}
  }{
    \QuoteNeu{\Gamma}{
      \VExp{cdr}{R}
    }{
      \TExp{cdr}{R}
    }{
      B_\SortCan%
    }
  }
\end{mathparpagebreakable}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgLookupAtom]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      i<n
      \\
      \IsThin{f}{n}{m}
      \\
      \IsVal{m}{A}{\SortCan}
    }{
      \DeclBox{\LookupAtom{\Gamma^+}{i^+}{A^-}{f^-}}
    }
  }
  \quad
  \DeclBox{
    \inferrule[JdgLookupVar]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      i<l
      \\
      \IsThin{f}{n}{m}
      \\
      \IsVal{m}{A}{\SortCan}
    }{
      \DeclBox{\LookupVar{\Gamma^+}{i^+}{A^-}{f^-}}
    }
  }
  \\
  \inferrule[LookupAtomVar]{
    \LookupAtom{\Gamma}{i}{A}{f}
  }{
    \LookupAtom{\Gamma.B}{i}{A}{f}
  }
  \and
  \inferrule[LookupAtomHere]{}{
    \LookupAtom{\Gamma.\nabla{}A}{0}{A}{\ThinId}
  }
  \and
  \inferrule[LookupAtomThere]{
    \LookupAtom{\Gamma}{n}{A}{f}
  }{
    \LookupAtom{\Gamma.\nabla{}A}{n+1}{A}{\ThinSkip{f}}
  }
  \\
  \inferrule[LookupVarAtom]{
    \LookupVar{\Gamma}{n}{A}{f}
  }{
    \LookupVar{\Gamma.\nabla{}B}{n}{A}{\ThinSkip{f}}
  }
  \and
  \inferrule[LookupVarHere]{}{
    \LookupVar{\Gamma.A}{0}{A}{\ThinId}
  }
  \and
  \inferrule[LookupVarThere]{
    \LookupVar{\Gamma}{n}{A}{f}
  }{
    \LookupVar{\Gamma.B}{n+1}{A}{f}
  }
\end{mathparpagebreakable}

\end{document}
