\documentclass{article}
\usepackage{amssymb}

\usepackage[tt=false]{libertine}
\usepackage{microtype}
\usepackage{hyperref}
\usepackage{mathpartir}
\usepackage[dvipsnames]{xcolor}
\usepackage{fullpage}

\usepackage{mathtools}

\DeclarePairedDelimiter\Parens{\lparen}{\rparen}
\DeclarePairedDelimiter\Angles{\langle}{\rangle}
\DeclarePairedDelimiter\Squares{[}{]}

\DeclarePairedDelimiter\Braces{\lbrace}{\rbrace}
\DeclarePairedDelimiter\Pipes{\lvert}{\rvert}

\newcommand\Len[1]{\Pipes*{#1}}

\newtheorem{remark}{Remark}



\usepackage{stmaryrd}

\title{Cubical Equality: Syntax}
\author{Jon Sterling}

\newcommand\FmtKwd[1]{\mathsf{#1}}

\newcommand\DeclBox[1]{\framebox{$\displaystyle{}#1$}}
\newcommand\FmtThin[1]{{\color{ProcessBlue}#1}}
\newcommand\XThin[3]{{#2}\rightarrowtriangle_{#1}{#3}}

\newcommand\Thin[2]{{#1}\rightarrowtriangle{#2}}
\newcommand\IsThin[3]{\FmtThin{#1}:\Thin{#2}{#3}}
\newcommand\IsXThin[4]{\FmtThin{#1}:\XThin{#2}{#3}{#4}}

\newcommand\ThinId{\mathsf{id}}
\newcommand\ThinKeep[1]{{#1}.\mathsf{c}}
\newcommand\ThinSkip[1]{{#1}.\mathsf{p}}
\newcommand\ThinRep[2]{{#1}.\Squares*{{\normalcolor{}#2}}}

\usepackage{xinttools}

\newcommand\FormatList[3]{%
  \xintFor ##1 in {#3} \do{%
    #1{##1}%
    \xintifForLast{}{#2}
  }
}



\newcommand\THIN{\mathbf{Thin}}
\newcommand\OpCat[1]{{#1}^{\mathsf{op}}}
\newcommand\SET{\mathbf{Set}}

\newcommand\Interval{\FmtKwd{dim}}
\newcommand\Bool{\FmtKwd{bool}}
\newcommand\Atom[1]{{\boldsymbol\alpha}_{#1}}
\newcommand\Var[1]{\mathsf{v}_{#1}}

\newcommand\SortChk{\FmtKwd{chk}}
\newcommand\SortInf{\FmtKwd{inf}}

\newcommand\Tm[3]{{#1}\mid{#2}\vdash{#3}}
\newcommand\FmtTm[1]{{\color{Violet}#1}}
\newcommand\IsTm[4]{{#1}\mid{#2}\vdash\FmtTm{#3}:{#4}}
\newcommand\IsChk[3]{\IsTm{#1}{#2}{#3}{\SortChk}}
\newcommand\IsInf[3]{\IsTm{#1}{#2}{#3}{\SortInf}}

\newcommand\TExp[2]{
  \FmtTm{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}


\newcommand\FmtVal[1]{{\color{Red}{#1}}}

\newcommand\VExp[2]{
  \FmtVal{
    \Parens*{
      \FmtKwd{#1}\
      \FormatList{}{\ }{#2}
    }
  }
}



\begin{document}
\maketitle

In these notes, we use colors to distinguish objects of different
(meta) sorts from each other, in order to avoid getting lost in a
hurricane of superscripts. As such, $\FmtTm{M}$ and $\FmtVal{M}$ are
to be understood as distinct schematic variables.

Many of the ideas in this note are inspired by conversations with and
notes by both Favonia and Conor McBride.

\section{Thinnings}

$X$-Thinnings are a defunctionalized representation of substitutions
which capture the idea of deleting some variables from within a
context, or possibly replacing them with an element of the family
$X:\SET^{\mathbb{N}}$. When $X$ is the empty family, these correspond
to the \emph{order-preserving embeddings} of Chapman.
%
We choose a representation of thinnings which lends itself to
efficient calculation, but is not canonical; therefore, any operation
on thinnings must be proved to be respect the algebraic laws of
thinnings in order to be well-defined.
\begin{mathparpagebreakable}
  \DeclBox{
    \IsXThin{f}{X}{m}{n}
  }
  \\
  \inferrule{
  }{
    \IsXThin{\ThinId}{X}{n}{n}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{m}{n}
  }{
    \IsXThin{\ThinKeep{f}}{X}{m+1}{n+1}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{m}{n}
  }{
    \IsXThin{\ThinSkip{f}}{X}{m+1}{n}
  }
  \and
  \inferrule{
    \IsXThin{f}{X}{m}{n}
    \\
    a:X_m
  }{
    \IsXThin{\ThinRep{f}{a}}{X}{m}{n+1}
  }
\end{mathparpagebreakable}

We will write $\THIN_X$ for the category of thinnings induced by the
above. To simplify notation, we write $\THIN$ for $\THIN_\varnothing$
and $\Thin{m}{n}$ for $\XThin{\varnothing}{m}{n}$.

\section{Terms}


In our term language, we distinguish between \emph{atoms} and
\emph{variables}, and their respective binders. Variable binders are
given operational meaning through substitution, whereas atom binders
are subject to open evaluation. Most binders are variable binders; the
only atom binder in our language comes from $\FmtKwd{coe}$.

\begin{remark}
  This is a matter of some subtlety in the context of
  \emph{normalization-by-evaluation} in which the evaluation and
  quotation phases of computation are distinguished: while we do not
  evaluate underneath a variable binder, during the quotation phase we
  \emph{do} instantiate such a variable binder with a semantic
  indeterminate or generic element: so, even though we end up
  transforming the interior of the binder, this is still done through
  substitution. In contrast, we do evaluate underneath atom binders.
\end{remark}

Terms are classified by sorts $\tau\in\Braces*{\SortChk,\SortInf}$; we
will write the judgment $\IsTm{n}{l}{M}{\tau}$ to mean that
$\FmtTm{M}$ is a term of sort $\tau$ with $n$ atoms and $l$
variables. In the term language, both atoms and variables are managed
using De Bruijn indices. An illustrative fragment of the syntax is
presented below.

\begin{mathparpagebreakable}
  \DeclBox{
    \IsTm{n}{l}{M}{\tau}
  }
  \\
  \and
  \inferrule[TmAtom]{
    i<n
  }{
    \IsInf{n}{l}{\Atom{i}}
  }
  \and
  \inferrule[TmVar]{
    i<l
  }{
    \IsInf{n}{l}{\Var{i}}
  }
  \and
  \inferrule[TmPi]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Pi}{A,B}
    }
  }
  \and
  \inferrule[TmSg]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l+1}{B}
  }{
    \IsChk{n}{l}{
      \TExp{\Sigma}{A,B}
    }
  }
  \and
  \inferrule[TmEq]{
    \IsChk{n}{l+1}{A}
    \\
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{
      \TExp{eq}{A,M,N}
    }
  }
  \and
  \inferrule[TmLam]{
    \IsChk{n}{l+1}{M}
  }{
    \IsChk{n}{l}{\TExp{\lambda}{M}}
  }
  \and
  \inferrule[TmCons]{
    \IsChk{n}{l}{M}
    \\
    \IsChk{n}{l}{N}
  }{
    \IsChk{n}{l}{\TExp{cons}{M,N}}
  }
  \and
  \inferrule[TmCar]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{car}{R}}
  }
  \and
  \inferrule[TmCdr]{
    \IsInf{n}{l}{R}
  }{
    \IsInf{n}{l}{\TExp{cdr}{R}}
  }
  \and
  \inferrule[TmDim0]{
  }{
    \IsChk{n}{l}{0}
  }
  \and
  \inferrule[TmDim1]{
  }{
    \IsChk{n}{l}{1}
  }
  \and
  \inferrule[TmUp]{
    \IsInf{n}{l}{R}
  }{
    \IsChk{n}{l}{\TExp{\uparrow}{R}}
  }
  \and
  \inferrule[TmApp]{
    \IsInf{n}{l}{R}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{@}{R,M}}
  }
  \and
  \inferrule[TmDown]{
    \IsChk{n}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{\TExp{\downarrow}{A,M}}
  }
  \and
  \inferrule[TmCoe]{
    \IsChk{n}{l}{I}
    \\
    \IsChk{n}{l}{J}
    \\
    \IsChk{n+1}{l}{A}
    \\
    \IsChk{n}{l}{M}
  }{
    \IsInf{n}{l}{
      \TExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
\end{mathparpagebreakable}

Note that altogether the definition above forms a family of functors
$\Parens*{\Tm{\square}{l}{\tau}}:\OpCat{\THIN}\to\SET$, whose
functorial action is the renaming of atoms.

\section{Semantic Domain}

The semantic domain of our language is really another syntax, in which
variables are replaced by semantic indeterminates (represented as De
Bruijn levels), and atoms remain represented as De Bruijn indices. The
semantic domain captures the weak-head normal forms of our language;
because we intend to develop a substitution-free operational semantics
using environments, we must naturally employ a notion of
\emph{closure}.

\newcommand\SortCan{\FmtKwd{can}}
\newcommand\SortNeu{\FmtKwd{neu}}
\newcommand\SortNf{\FmtKwd{nf}}
\newcommand\SortClo{\FmtKwd{clo}}
\newcommand\SortBClo{\FmtKwd{bclo}}
\newcommand\SortEnv[1]{\FmtKwd{env}_{#1}}
\newcommand\IsVal[3]{{#1}\Vdash\FmtVal{#2}:{#3}}
\newcommand\Val[2]{{#1}\Vdash{#2}}

\newcommand\Clo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}

\newcommand\BClo[4]{
  \Squares*{
    \FmtThin{#1}%
    \mathbin{\color{gray}*}%
    \Angles*{
      \FmtTm{#4}
      \mathbin{\color{gray}\triangleleft^+}%
      \FmtThin{#2}
      \mathbin{\color{gray}*}%
      \FmtVal{#3}
    }
  }
}


Values are classified by sorts
$\tau\in\Braces*{\SortCan,\SortNeu,\SortNf,\SortEnv{l},\SortClo,\SortBClo}$; for
such a sort $\tau$, we will write $\IsVal{n}{M}{\tau}$ to mean that
$\FmtVal{M}$ is a value of sort $\tau$ with $n$ atoms. We no longer
track the number of variables, because these are replaced by
indeterminates in the form of De Bruijn levels (which have an absolute
reference).

\begin{mathparpagebreakable}
  \DeclBox{
    \IsVal{n}{M}{\tau}
  }
  \\
  \inferrule[ValAtom]{
    i<n
  }{
    \IsVal{n}{\Atom{i}}{\SortCan}
  }
  \and
  \inferrule[ValGen]{
  }{
    \IsVal{n}{\Var{l}}{\SortNeu}
  }
  \and
  \inferrule[ValDown]{
    \IsVal{n}{A}{\SortCan}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{
      \VExp{\downarrow}{A,M}
    }{\SortNf}
  }
  \and
  \inferrule[ValUp]{
    \IsVal{n}{A}{\SortCan}
    \\
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{
      \VExp{\uparrow}{A,R}
    }{\SortCan}
  }
  \and
  \inferrule[ValClo]{
    \IsXThin{g}{\Parens*{\Val{\square}{\SortCan}}}{o}{n}
    \\
    \IsThin{f}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l}{M}{\SortChk}
  }{
    \IsVal{o}{
      \Clo{g}{f}{\rho}{M}
    }{\SortClo}
  }
  \and
  \inferrule[ValBClo]{
    \IsXThin{g}{\Parens*{\Val{\square}{\SortCan}}}{o}{n}
    \\
    \IsThin{f}{n}{m}
    \\
    \IsVal{m}{\rho}{\SortEnv{l}}
    \\
    \IsTm{n}{l+1}{M}{\SortChk}
  }{
    \IsVal{o}{
      \BClo{g}{f}{\rho}{M}
    }{\SortBClo}
  }
  \and
  \inferrule[ValEnv]{
    \forall{i<l}.\ \IsVal{n}{M_i}{\SortCan}
  }{
    \IsVal{n}{\Squares{M_i}_{i<l}}{\SortEnv{l}}
  }
  \\
  \inferrule[ValPi]{
    \IsVal{n}{A}{\SortClo}
    \\
    \IsVal{n}{A}{\SortBClo}
  }{
    \IsVal{n}{
      \VExp{\Pi}{A,B}
    }{\SortCan}
  }
  \and
  \inferrule[ValLam]{
    \IsVal{n}{M}{\SortClo}
  }{
    \IsVal{n}{\VExp{\lambda}{M}}{\SortCan}
  }
  \and
  \inferrule[ValApp]{
    \IsVal{n}{R}{\SortNeu}
    \\
    \IsVal{n}{M}{\SortNf}
  }{
    \IsVal{n}{\VExp{@}{R,M}}{\SortNeu}
  }
  \and
  \inferrule[ValCons]{
    \IsVal{n}{M}{\SortClo}
    \\
    \IsVal{n}{N}{\SortClo}
  }{
    \IsVal{n}{\VExp{cons}{M,N}}{\SortCan}
  }
  \and
  \inferrule[ValCar]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{car}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCdr]{
    \IsVal{n}{R}{\SortNeu}
  }{
    \IsVal{n}{\VExp{cdr}{R}}{\SortNeu}
  }
  \and
  \inferrule[ValCoe]{
    \IsVal{n}{I}{\SortCan}
    \\
    \IsVal{n}{J}{\SortCan}
    \\
    \IsVal{n+1}{A}{\SortCan}
    \\
    \IsVal{n}{M}{\SortCan}
  }{
    \IsVal{n}{
      \VExp{coe}{I,J,A,M}
    }{\SortCan}
  }
\end{mathparpagebreakable}

As with terms, the definitions above induce a family of functors
$\Parens*{\Val{\square}{\tau}}:\OpCat{\THIN_{\Val{\square}{\SortCan}}}\to\SET$. The functorial
action of thinnings on closures is composition, which comports with
the view of closures as a left Kan extension which suspends a
thinning.


\section{Evaluation}
\newcommand\EvalClo[2]{\FmtVal{#1}\Downarrow\FmtVal{#2}}
\newcommand\Eval[5]{\FmtThin{#2}*\FmtVal{#3}\vDash\FmtTm{#4}\mathrel{\Downarrow_{\FmtThin{#1}}}\FmtVal{#5}}
\newcommand\Apply[3]{\FmtVal{#1}\mathrel{@}\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\InstClo[3]{\FmtVal{#1}\bullet\FmtVal{#2}\Downarrow\FmtVal{#3}}
\newcommand\ThinVal[2]{\widehat{\FmtThin{#1}}\Parens*{\FmtVal{#2}}}

At a high level, evaluation takes terms to values; at a finer-grained
level, however, we will evaluate with respect to a thinning
$\FmtThin{g}$ and an environment $\FmtVal{\rho}$ together with a
thinning $\FmtThin{f}$; this allows us to avoid actually executing
thinnings and substitutions until the last moment possible. In fact,
the preceding sentence can be rephrased as construing evaluation as a
relation $\EvalClo{M_\SortClo}{M_\SortCan}$ where
$\IsVal{n}{M_\SortClo}{\SortClo}$ and
$\IsVal{n}{M_\SortCan}{\SortCan}$.

We will write $\Eval{g}{f}{\rho}{M}{M}$ as a notation for
$\EvalClo{\Clo{g}{f}{\rho}{M}}{M}$, when it is well-formed:

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgEval]{
      \IsThin{g}{o}{n}
      \\
      \IsThin{f}{n}{m}
      \\
      \IsVal{m}{\rho}{\SortEnv{l}}
      \\
      \IsTm{n}{l}{M}{\tau}
      \\
      \IsVal{o}{M}{\SortCan}
    }{
      \DeclBox{
        \Eval{g^+}{f^+}{\rho^+}{M^+}{M^-}
      }
    }
  }
  \\
  \inferrule[EvalAtom]{}{
    \Eval{g}{f}{\rho}{\Atom{i}}{
      \ThinVal{g}{\Atom{i}}
    }
  }
  \and
  \inferrule[EvalVar]{}{
    \Eval{g}{f}{\rho}{\Var{l}}{
      \ThinVal{
        g\circ{}f
      }{\rho_l}
    }
  }
  \and
  \inferrule[EvalPi]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Pi}{A,B}
    }{
      \VExp{\Pi}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalSg]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\Sigma}{A,B}
    }{
      \VExp{\Sigma}{
        \Clo{g}{f}{\rho}{A},
        \BClo{g}{f}{\rho}{B}
      }
    }
  }
  \and
  \inferrule[EvalEq]{}{
    \Eval{g}{f}{\rho}{
      \TExp{eq}{A,M,N}
    }{
      \VExp{eq}{
        \BClo{g}{f}{\rho}{A},
        \Clo{g}{f}{\rho}{M},
        \Clo{g}{f}{\rho}{N}
      }
    }
  }
  \and
  \inferrule[EvalLam]{}{
    \Eval{g}{f}{\rho}{
      \TExp{\lambda}{M}
    }{
      \VExp{\lambda}{
        \BClo{g}{f}{\rho}{M}
      }
    }
  }
  \and
  \and
  \inferrule[EvalUp]{
    \Eval{g}{f}{\rho}{R}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\uparrow}{R}
    }{
      M
    }
  }
  \and
  \inferrule[EvalDown]{
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{\downarrow}{A,M}
    }{M}
  }
  \and
  \inferrule[EvalCoe]{
    \Eval{g}{f}{\rho}{I}{I}
    \\
    \Eval{g}{f}{\rho}{J}{J}
    \\
    \Eval{\ThinKeep{g}}{\ThinSkip{f}}{\rho}{A}{A}
    \\
    \Eval{g}{f}{\rho}{M}{M}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{coe}{I,J,A,M}
    }{
      \VExp{coe}{
        I,
        J,
        A,
        M
      }
    }
  }
  \and
  \inferrule[EvalApp]{
    \Eval{g}{f}{\rho}{R}{M_{\mathsf{fun}}}
    \\
    \Eval{g}{f}{\rho}{M}{M_{\mathsf{arg}}}
    \\
    \Apply{M_{\mathsf{fun}}}{M_{\mathsf{arg}}}{N}
  }{
    \Eval{g}{f}{\rho}{
      \TExp{@}{
        R,
        M
      }
    }{
      N
    }
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgInst]{
      \IsVal{n}{M}{\SortBClo}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\InstClo{M^+}{N^+}{O^-}}
    }
  }
  \and
  \inferrule[InstBClo]{
    \Eval{g}{f}{\Squares*{N,\rho}}{M}{O}
  }{
    \InstClo{
      \BClo{g}{f}{\rho}{M}
    }{N}{O}
  }
\end{mathparpagebreakable}


\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgApply]{
      \IsVal{n}{M}{\SortCan}
      \\
      \IsVal{n}{N}{\SortCan}
      \\
      \IsVal{n}{O}{\SortCan}
    }{
      \DeclBox{\Apply{M^+}{N^+}{O^-}}
    }
  }
  \\
  \inferrule[ApplyLam]{
    \InstClo{M}{N}{O}
  }{
    \Apply{\VExp{\lambda}{M}}{N}{O}
  }
  \and
  \inferrule[ApplyUpPi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortClo}{N}{B_\SortCan}
  }{
    \Apply{
      \VExp{\uparrow}{
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        R
      }
    }{N}{
      \VExp{\uparrow}{
        B_\SortCan,
        \VExp{@}{
          R,
          \VExp{\downarrow}{
            A_\SortCan,
            N
          }
        }
      }
    }
  }
  \and
  \inferrule[ApplyCoePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \InstClo{B_\SortBClo}{
      \VExp{coe}{
        \ThinVal{\ThinSkip{\ThinId}}{J},
        \Atom{0},
        \ThinVal{
          \ThinKeep{\ThinSkip{\ThinId}}
        }{A_\SortCan},
        \ThinVal{\ThinSkip{\ThinId}}{N}
      }
    }{
      B_\SortCan{}
    }
    \\
    \Apply{M}{
      \VExp{coe}{
        J,
        I,
        A_\SortCan,
        N
      }
    }{O}
  }{
    \Apply{
      \VExp{coe}{
        I,
        J,
        \VExp{\Pi}{A_\SortClo,B_\SortBClo},
        M
      }
    }{N}{
      \VExp{coe}{
        I,
        J,
        B_\SortCan,
        O
      }
    }
  }
\end{mathparpagebreakable}


\section{Quotation}

\newcommand\QuoteCan[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\ni\FmtVal{#3}\Uparrow\FmtTm{#4}
}

\newcommand\QuoteNeu[4]{
  \FmtVal{#1}\vDash\FmtVal{#2}\Uparrow\FmtTm{#3}\in\FmtVal{#4}
}

\newcommand\SortCtx[1]{\FmtKwd{ctx}_{#1}}

\subsection{Semantic contexts}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgCtx]{}{
      \DeclBox{\IsVal{n^-}{\Gamma}{\SortCtx{l^-}}}
    }
  }
  \\
  \inferrule[CtxNil]{}{
    \IsVal{0}{\cdot}{\SortCtx{0}}
  }
  \and
  \inferrule[CtxExtVar]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n}{\Gamma.A}{\SortCtx{l+1}}
  }
  \and
  \inferrule[CtxExtAtom]{
    \IsVal{n}{\Gamma}{\SortCtx{l}}
    \\
    \IsVal{n}{A}{\SortCan}
  }{
    \IsVal{n+1}{\Gamma.\nabla{}A}{\SortCtx{l}}
  }
\end{mathparpagebreakable}

\subsection{Quotation}

\begin{mathparpagebreakable}
  \DeclBox{
    \inferrule[JdgQuoteCan]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{A}{\SortCan}
      \\
      \IsVal{n}{M}{\SortCan}
      \\
      \IsTm{n}{l}{M}{\SortChk}
    }{
      \DeclBox{\QuoteCan{\Gamma^+}{A^+}{M^+}{M^-}}
    }
  }
  \and
  \DeclBox{
    \inferrule[JdgQuoteNeu]{
      \IsVal{n}{\Gamma}{\SortCtx{l}}
      \\
      \IsVal{n}{R}{\SortNeu}
      \\
      \IsTm{n}{l}{M}{\SortNeu}
      \\
      \IsVal{n}{l}{A_\SortCan}
    }{
      \DeclBox{\QuoteNeu{\Gamma^+}{R^+}{R^-}{A^-}}
    }
  }
  \\
  \inferrule[QuotePi]{
    \EvalClo{A_\SortClo}{A_\SortCan}
    \\
    \QuoteCan{\Gamma}{C}{A_\SortCan}{A}
    \\
    \InstClo{B_\SortClo}{
      \Var{\Len{\Gamma}}
    }{
      B_\SortCan{}
    }
    \\
    \QuoteCan{\Gamma.A_\SortCan}{C}{B_\SortCan}{B}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{\Pi}{A_\SortClo,B_\SortBClo}
    }{
      \TExp{\Pi}{
        A,
        B
      }
    }
  }
  \and
  \inferrule[QuoteLam]{
    \EvalClo{A}{A_\SortCan}
    \\
    \InstClo{B}{\Var{\Len{\Gamma}}}{B_\SortCan}
    \\
    \Apply{M}{\Var{\Len{\Gamma}}}{N}
    \\
    \QuoteCan{\Gamma.A_\SortCan}{B_\SortCan}{N}{N}
  }{
    \QuoteCan{\Gamma}{
      \VExp{\Pi}{A,B}
    }{M}{
      \TExp{\lambda}{N}
    }
  }
  \and
  \inferrule[QuoteCoeBool]{
    \QuoteCan{\Gamma}{\Bool}{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \Bool,
        M
      }
    }{
      M
    }
  }
  \and
  \inferrule[QuoteCoeUp]{
    \QuoteCan{\Gamma}{\Interval}{I}{I}
    \\
    \QuoteCan{\Gamma}{\Interval}{J}{J}
    \\
    \QuoteNeu{\Gamma.\nabla\Interval}{R}{R}{A'}
    \\
    \QuoteCan{\Gamma}{
      \ThinVal{
        \ThinRep{\ThinId}{\FmtVal{I}}
      }{A'}
    }{M}{M}
  }{
    \QuoteCan{\Gamma}{C}{
      \VExp{coe}{
        I,
        J,
        \VExp{\uparrow}{A,R},
        M
      }
    }{
      \TExp{\uparrow}{
        \TExp{coe}{
          I,
          J,
          \TExp{\uparrow}{R},
          M
        }
      }
    }
  }
\end{mathparpagebreakable}

\end{document}
